\documentclass[shortnames]{Z}
%% need no \usepackage{Sweave}
\SweaveOpts{engine=R, eps=FALSE, echo=FALSE, results=hide}

\usepackage{amsfonts}

\title{Escaping RGBland: Selecting Colors for Statistical Graphics}
\author{Achim Zeileis\\Wirtschaftsuniversit\"at Wien
   \And Kurt Hornik\\Wirtschaftsuniversit\"at Wien
   \And Paul Murrell\\The University of Auckland}
\Plainauthor{Achim Zeileis, Kurt Hornik, Paul Murrell}
\Keywords{qualitative palette, sequential palette, diverging palette, HCL colors, HSV colors, perceptually-based color space}

\Abstract{
  Statistical graphics are often augmented by the use of color
  coding information contained in some variable. When this involves
  the shading of areas (and not only points or lines)---e.g., as in bar plots, pie charts,
  mosaic displays or heatmaps---it is important that the colors are perceptually based
  and do not introduce optical illusions or systematic bias. Here, we discuss
  how the perceptually-based Hue-Chroma-Luminance (HCL) color space can be used for deriving suitable
  color palettes for coding categorical data (qualitative palettes) and numerical
  variables (sequential and diverging palettes).
}

\begin{document}

<<preliminaries>>=
library("colorspace")
library("mvtnorm")
library("KernSmooth")
library("dichromat")

source("functions.R")
source("Nigeria/bnd.R")

hcl2hex <- function(h, c, l, gamma = 2.4, fixup = TRUE)
  hex(polarLUV(L = l, C = c, H = h), gamma = gamma, fixup = fixup)

generate_png <- TRUE
@

\section{Introduction} \label{sec:intro}

%FIXME% The intro is a bit too long and needs to be condensed.

Color is an integral element of graphical displays in general, 
and many statistical
graphics in particular. 
It is easy to create color graphics with any statistical software 
package and color images are therefore virtually omnipresent in electronic
publications such as technical reports, presentation slides, or the electronic
version of journal articles (e.g., in \emph{Computational Statistics \& Data Analysis})
and increasingly also in printed journals. However, more often than not,
color choice in such displays is sub-optimal because selecting colors is not
a trivial task and there is relatively
little guidance about how to choose appropriate colors for a particular visualization. 
When selecting colors for a statistical graphic,
there are three main obstacles to overcome:

\textbf{The colors should not be unappealing.}
It is not necessary for the colors in a statistical plot to reflect 
fashion trends, but basic principles such as avoiding large areas
of fully saturated colors \citep{color:Tufte:1990}
should be adhered to. 
The requirement is not that the user should have
a degree in graphic design, but that the software should provide users with an
intuitive way to select colors and control their basic properties. 
Thus, it is necessary to employ a \emph{color model}
or \emph{color space} that describes colors in terms of their perceptual
properties: hue, brightness, and colorfulness.

A color model typically supported by software packages involves
 the specification
of colors as Red-Green-Blue (RGB) triplets. However, this specification
corresponds to color generation on
a computer screen 
\citep[see][]{color:Poynton:2000}
rather than
corresponding to human color perception. For humans, it is
virtually impossible to control the perceptual properties of a color in this
color space because there is no single dimension that corresponds to, e.g.,
the hue or the brightness of the color. As a consequence, 
various perceptually-based
color spaces have been suggested, where each dimension of the color space can
be matched with a perceptual property. One approach widely implemented in
software packages involves
 Hue-Saturation-Value (HSV) triplets \citep{color:Smith:1978},
a simple transformation of RGB triplets \citep[see][]{color:Wiki+HSV:2007}.
Unfortunately, the dimensions in HSV space map poorly to perceptual
properties and the use of HSV colors encourages the use of 
highly saturated colors. 
A perceptually based color model that avoids
these problems involves
Hue-Chroma-Luminance (HCL) triplets \citep[see][]{color:Ihaka:2003},
which is
a transformation of CIELUV color space \citep[see][]{color:Wiki+CIELUV:2007}.
This is the color space we advocate in this article.


\textbf{The colors in a statistical graphic should cooperate with each other.}
The typical purpose of color in a statistical graphic is to distinguish
between different areas or symbols in the plot---to distinguish between
different groups or between different levels of a variable.  This means
that there will typically be several colors, or a \emph{palette}
of colors, used within a plot and that those colors should be related to
each other.

A natural solution for this task is to vary (at least) one perceptual property
of the colors, e.g., the hue or the brightness, keeping other properties
fixed. In a perceptually based color space, this corresponds to selecting
colors by traversing paths through this space along its dimensions.
This approach is implemented in many color picker tools
\citep{color:Moretti+Lyons:2002,color:Meier+Spalter+Karelitz:2004},
however, these are typically based on the HSV model.
As argued above, the dimensions in HSV space are not truly independent and
hence it is not possible to vary just one perceptual property while keeping
the others fixed. This means that it is relatively
difficult to select sets of HSV coordinates that yield colors that are
``in harmony'' \citep[see][]{color:Munsell:1905}. For statistical graphics,
this is important because it can introduce size distortions in the perception
of shaded areas and can produce
 optical illusions \citep{color:Cleveland+McGill:1983}.
These problems can again be addressed by employing the HCL color space. 
In addition to
the earlier point that HCL space
is useful because it allows humans to understand where within the space
a particular HCL triplet is located,  
HCL also allows
us to understand motion within the color space because
distances between colors  have an intuitive and rational meaning.  

\textbf{The colors should work everywhere.}
The final issue to deal with is that, in an ideal situation, colors 
should be selected so that they continue to work in any 
context.  For example, different areas of a plot should still be 
distinguishable when the graphic is displayed on an LCD projector
rather than a computer screen, or when it is printed on a grayscale
printer, or when the person viewing the graphic is color-blind.
These goals cannot always be attained, but attention should be paid
to these issues and in many situations it is also possible to
resolve any problems.

An example of this approach is \pkg{ColorBrewer.org}
\citep{color:Harrower+Brewer:2003}, an online tool for selecting color
schemes for maps. It provides a collection of prefabricated palettes, 
information about the suitability for printers or color-blind viewers,
and guidance on how to choose a suitable palette for coding various types of
information. The drawback to this tool is that it only provides a fixed
set of colors for each palette and there is no way to extend the
existing palettes.

Following \cite{color:Brewer:1999} and \cite{color:Harrower+Brewer:2003}, we 
take a similar approach and distinguish three types of palettes: qualitative,
sequential and diverging. The first is tailored for coding categorical
information and the latter two are aimed at numerical or ordinal
variables. Unlike \pkg{ColorBrewer.org}, we suggest
a general principle for selecting colors by 
traversing paths along perceptual axes in
HCL color space. Consequently, the user can decide which path exactly should be
taken and how many colors should be selected. Furthermore, by matching
the paths with perceptual meaning, the suitability of a palette for color-blind
viewers or grayscale printing can be assessed.

%% Given a mapping from HCL to RGB coordinates, our formulas are
%% extremely easy to implement in software and we provide such an implementation
%% in the \proglang{R} language \citep{color:R:2007} using the powerful \proglang{R} graphics
%% system \citep[see][]{color:Murrell:2006} and the HCL
%% color implementation from package \pkg{colorspace} \citep{color:Ihaka:2006}. This gives the user
%% both a conceptual and computational tool box for experimenting with color palettes for
%% a particular display.

The remainder of the paper is organized as follows: Section~\ref{sec:motivation} provides
some motivating examples, showing how typical HSV-based graphics can be enhanced
by using HCL-based palettes. Section~\ref{sec:spaces} gives a brief introduction
to the underlying HSV and HCL color spaces before Section~\ref{sec:palettes} 
suggests strategies for deriving HCL-based qualitative, sequential, and diverging palettes.
Section~\ref{sec:software} offers some general remarks on the implementation in statistical
software packages as well as some details on the implementation in the \proglang{R}
system for statistical computing \citep{color:R:2007}.
Section~\ref{sec:discussion} concludes the paper with a discussion.


\section{Motivation} \label{sec:motivation}

To show what can be gained by selecting appropriate color schemes,
we present two examples for typical color graphics, contrasting
commonly-used HSV palettes with more suitable HCL palettes.
Both examples and all HSV palettes are taken from (the electronic
version of) recent publications in
\emph{Computational Statistics \& Data Analysis} (Volume~51).

\setkeys{Gin}{width=\textwidth}
\begin{figure}[t!]
\begin{center}
<<bkde>>=
if(generate_png) {
  data("geyser", package = "MASS")
  ## geyser2 <- cbind(geyser$duration[-299], geyser$waiting[-1])
  geyser2 <- cbind(geyser$duration, geyser$waiting)
  dens <- bkde2D(geyser2, bandwidth = c(0.2, 3), gridsize = c(201, 201))
  plot_bkde2D <- function(x, col = NULL, xlab = "", ylab = "", legend = FALSE, ...) {
    if(is.null(col)) col <- rev(gray.colors(33))
    if(legend) {
      filled.contour(x$x1, x$x2, x$fhat, col = col, nlevels = length(col), xlab = xlab, ylab = ylab, ...)
    } else {
      image(x$x1, x$x2, x$fhat,
        breaks = seq(from = min(x$fhat), to = max(x$fhat), length.out = length(col) + 1),
        xlab = xlab, ylab = ylab, col = col, axes = FALSE, cex.lab = 1.5, ...)
      box()
      axis(1, cex.axis = 1.5)
      axis(2, cex.axis = 1.5)
    }
    invisible(x)
  }

  png(file = "bkde.png", height = 810, width = 840)
  par(mfrow = c(2, 2), mar = c(4.5, 3.5, 1, 1))
  plot_bkde2D(dens, col = hsv(seq(from = 2/3, to = 0, length = 33), 0.8, 0.9))
  ## plot_bkde2D(dens, col = rainbow(33, start = 1/3, end = 1, v = 0.8, s = 0.9))
  plot_bkde2D(dens, col = rev(sequential_hcl(33, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  plot_bkde2D(dens, col = rev(heat.colors(33)))
  plot_bkde2D(dens, col = rev(heat_hcl(33, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  dev.off()
}
@
\includegraphics{bkde}
\setkeys{Gin}{width=.47\textwidth}
<<bkde-pal>>=
if(generate_png) {
  png(file = "bkde-pal.png", height = 160, width = 396)
  par(mfrow = c(4, 1), mar = c(0.5, 0, 0, 0), oma = c(2, 1.5, 0, 1.5))
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    hsv(seq(from = 2/3, to = 0, length = 99), 0.8, 0.9))
    ## rainbow(99, start = 1/3, end = 1, v = 0.8, s = 0.9))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat.colors(99)))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(heat_hcl(99, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))))
  box()
  plot(0, 0, type="n", xlim = c(0, 0.03), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = 0, to = 0.03, length.out = 99), lwd = 4, col = 
    rev(sequential_hcl(99, c = 0, l = c(30, 90), power = c(1/5, 1.5))))
  box()
  axis(1, cex.axis = 1.8)
  dev.off()
}
@
\includegraphics{bkde-pal}
\caption{\label{fig:bkde} Bivariate density estimation of duration (x-axis) and
waiting time (y-axis) for Old Faithful geyser eruptions. The palettes employed
are (counterclockwise) an HSV-based rainbow, HSV-based heat colors, HCL-based heat colors
and grayscales.}
\end{center}
\end{figure}

Our first illustration is a heatmap, a very popular display for visualizing a scalar function of
two arguments. Here, we use a bivariate kernel density estimate \citep[for the Old Faithful
geyser eruptions data from][]{color:Azzalini+Bowman:1990}---other typical applications include 
classification maps \citep[as in][Figure~2]{color:Tenenhaus+Giron+Viennet:2007},
function surfaces \citep[as in][Figure~8]{color:Harezlak+Coull+Laird:2007}, or
measurements on a spatial grid \citep[as in][Figure~3]{color:Gelfand+Banerjee+Sirmans:2007}.
Figure~\ref{fig:bkde} shows a heatmap bringing out the relationship between the duration
of an eruption of the Old Faithful geyser in Yellowstone National Park 
and the waiting time for this eruption. It reveals a multi-modal distribution: short waiting
times (around 50 minutes) are typically followed by a long eruption (around 4 minutes)
whereas long waiting times (around 80 minutes) can be followed by either a long
or short eruption (around 2 minutes). 

A simple and very effective palette for such a display is a set of gray colors
as in the top right panel of Figure~\ref{fig:bkde}. This is often (appropriately) used
in printed papers when the journal does not offer color graphics---however, in journals
that support color graphics (or on presentation slides and in interactive usage in statistical
software packages), many users prefer to have colored displays and most often use HSV
palettes (as in the two left two panels). These palettes code the variable of interest
by varying hue in an HSV color wheel, yielding a ``rainbow'' of colors, as done by 
\citet[Figure~8]{color:Harezlak+Coull+Laird:2007}
or \citet[Figure~2]{color:Tenenhaus+Giron+Viennet:2007}. 
The palette in the upper left panel
codes increasing density by going from a blue to a red hue (via green and yellow)---a similar
strategy are the ``heat colors'' in the lower left panel that increase from yellow to red.
The latter works a bit better than the former, however both palettes exhibit several drawbacks.
The modes in the map look much more like ``rings'' rather than a smoothly increasing/decreasing 
density. The heatmap looks very flashy which---although good for drawing attention to a plot---makes
it hard to hold the attention of the viewer for a longer time because the large areas shaded
with saturated colors can be distracting and produce after-image effects \citep{color:Ihaka:2003}.

In contrast, the gray colors used in the top right panel do not exhibit the same disadvantages,
coding the variable of interest much better and without flashy colors. If, however, the user wants
to increase the contrast by adding some color to the plot, this could be done by using a better
balanced version of the heat colors (as shown in the bottom right panel). These colors also
increase from a yellow to a red hue while using the same brightness levels as in the grayscale
palette. Thus, when converted to a grayscale or printed out on a grayscale printer
(as in the printed version of \emph{Computational Statistics \& Data Analysis}),
the upper and lower right panel would look (virtually) identical.
Both palettes have in common that they give increasing perceptual emphasis
to regions with increasing density, resulting in a heatmap that highlights the (small)
interesting high-density regions and not to the large low-density regions surrounding them.
By balancing the lower right panel with respect to its brightness levels (i.e., light/dark contrasts),
it is assured that the graphic is intelligible for color-blind readers and that the same graphic works in
colored electronic versions and printed grayscale versions of a publication.


\setkeys{Gin}{width=\textwidth}
\begin{figure}[p!]
\begin{center}
<<nigeria>>=
if(generate_png) {
  m <- read.bnd("Nigeria/nigeria37.bnd")
  fit <- read.table("Nigeria/reml_purespatial_f_district_spatial.res", header = TRUE)
  fit <- fit[order(fit$district),]

  png(file = "nigeria.png", height = 1050, width = 840)
  par(mfrow = c(3, 2), mar = c(1.22, 0.82, 1.02, 0.82))
  plot(m, z = fit$pmode, fill = rev(rainbow(99, start = 0, end = 1/3)),
    zlim = c(-0.65, 0.65), legend = FALSE)
  plot(m, z = fit$pmode, fill = dichromat(rev(rainbow(99, start = 0, end = 1/3)), type = "protan"),
    zlim = c(-0.65, 0.65), legend = FALSE)
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = dichromat(rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)), type = "protan"))
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = rev(diverge_hcl(99, h = c(300, 120), c = 60, l = c(45, 90), power = 1.2)))
  plot(m, z = fit$pmode, zlim = c(-0.65, 0.65), legend = FALSE,
    fill = dichromat(rev(diverge_hcl(99, h = c(300, 120), c = 60, l = c(45, 90), power = 1.2)), type = "protan"))
  dev.off()
}
@
\includegraphics{nigeria}
\setkeys{Gin}{width=.47\textwidth}
<<nigeria-pal>>=
if(generate_png) {
  png(file = "nigeria-pal.png", height = 120, width = 396)
  par(mfrow = c(3, 1), mar = c(0.5, 0, 0, 0), oma = c(2, 0.2, 0, 0.2))
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(rainbow(99, start = 0, end = 1/3)))
  box()
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(diverge_hcl(99, h = c(0, 120), c = 60, l = c(45, 90), power = 1.2)))
  box()
  plot(0, 0, type="n", xlim = c(-0.65, 0.65), ylim = c(0, 1),
    xaxs = "i", yaxs = "i", axes = FALSE, xlab = "", ylab="")
  abline(v = seq(from = -0.65, to = 0.65, length.out = 99), lwd = 4, col = 
    rev(diverge_hcl(99, h = c(300, 120), c = 60, l = c(45, 90), power = 1.2)))
  box()
  axis(1, cex.axis = 1.8)
  dev.off()
}
@
\includegraphics{nigeria-pal}
\caption{\label{fig:nigeria} Posterior mode estimates for childhood mortality in Nigeria.
The color palettes employed are an HSV-based rainbow and two HCL-based diverging palettes.
In the right panels red-green contrasts are collapsed to emulate protanopic vision.}
\end{center}
\end{figure}

The second example is presented in Figure~\ref{fig:nigeria}
\citep[taken from][Figure~5, left]{color:Kneib:2006}, depicting posterior mode estimates
for childhood mortality in different regions of Nigeria. Spatial variations (not included
in the model) in childhood mortality are brought out by shading a map according to the
corresponding model deviations, 
revealing decreased mortality in the south-west and increased mortality in
the north-east. \cite{color:Kneib:2006} uses an HSV-based palette coding the residuals by
the hue, going from green via yellow to red (see the upper left panel of Figure~\ref{fig:nigeria}).
Similar approaches are used by \citet[Figure~8]{color:Harezlak+Coull+Laird:2007} and
\citet[Figure~2]{color:Tenenhaus+Giron+Viennet:2007}. 
Our first HCL-based palette in the middle left panel also employs green
and red hues for negative and postive residuals respectively, but codes neutral values
(around 0) by a neutral light gray. Compared to the HSV-based palette, this offers again
a number of advantages: only the interesting areas are highlighted by high-chroma colors;
flashy colors are avoided making it easier to look at the display for a longer time; positive
and negative residuals with the same absolute size receive the same perceptual weight
by being balanced with respect to their brightness.

Another advantage of the HCL-based palette becomes apparent when we collapse the
red-green distinctions in the colors to emulate what a person with protanopia
(a common red-green color blindness) would see. The right panel of Figure~\ref{fig:nigeria}
displays the respective palettes from the left panel, but transformed for protanopic
vision using the tools of \cite{color:Lumley:2006}. In the upper right panel, the
low-mortality regions in the south-west just ``disappear'' because they are transformed
to virtually the same yellow as the average-mortality regions. In contrast, in the middle
right panel, regions with increased and decreased mortality remain clearly distinguishable.
Only the type and amount of color is changed (red turns gray, green turns yellow/brown) but
regions with large deviations are still easily indentifiable by being balanced towards
darker grays. To avoid that one of the two ``branches'' of the palette is only gray
in the protanopic version, we could also employ a purple (rather than a red) hue for
positive deviations. This is used in the lower panels of Figure~\ref{fig:nigeria}
showing that after collapsing red-green distinctions, a useful yellow/brown--gray--blue
palette remains from the original green--gray--purple palette. Thus, the lower left
panel could be used ensuring that it works for both normal and protanopic vision.
Similar arguments hold for deuteranopic vision.



\section{Color spaces} \label{sec:spaces}

For choosing color palettes it is helpful to have an idea how
human color vision evolved. It has been hypothesized that it developed in three
distinct stages: 1.~perception of \emph{light/dark} contrasts (monochrome only),
2.~\emph{yellow/blue} contrasts (usually associated with our notion of warm/cold colors),
3.~\emph{green/red} contrasts (helpful for assessing the ripeness of fruit). See 
\cite{color:Ihaka:2003} and \cite{color:Lumley:2006} for more details and references.

Due to these three color axes, colors are typically described as
locations in 3-dimensional spaces. However, human perception of color
does not correspond to the physiological axes above, but rather to polar
coordinates in the color plane (yellow/blue vs.~green/red) plus a third
light/dark axis. Thus, perceptually-based color spaces try to capture the
perceptual axes
\begin{itemize}
  \item \emph{hue} (dominant wavelength)
  \item \emph{chroma} (colorfulness, intensity of color as compared to gray)
  \item \emph{luminance} (brightness, amount of gray)
\end{itemize}

A popular implementation of such a color space, available in many graphics and
statistics software packages, are HSV colors. They are a simple transformation of RGB colors
and are defined by a triplet $(H, S, V)$ with $H \in [0, 360]$ and $S, V \in [0, 100]$.
%% HSV space has the shape of a single regular cone (often inflated to a regular
%% cylinder). Vertical sections through this space are shown in the upper panel
%% of Figure~\ref{fig:hsv-hcl}, depicting hue and saturation given different value levels.
Although simple to specify and easily available in many computing environments,
HSV colors have a fundamental drawback: its three dimensions map to the three
dimensions of human color perception very poorly. The three dimensions are
confounded:
%% which is most easily seen when converting the vertical sections to 
%% gray scale images in Figure~\ref{fig:hsv-hcl-gray}. Clearly,
The brightness of
colors is not uniform over hues and saturations (given value, see Figure~\ref{fig:wheel})---therefore,
HSV colors are often not considered to be perceptually based.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[b!]
\begin{center}
<<wheel, fig=TRUE, height=3.64, width=10>>=
par(mar = rep(0.8, 4), mfrow = c(1, 2))
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1), oma = c(0, 0, 0, 0))
par(lwd = 3)
pie(rep(1,6), radius = 1, col = rainbow(6), labels = 360 * 0:5/6)
par(lwd = 0.5, new = TRUE)
pie(rep(1, 90), radius = 1, col = rainbow(90), border = NA, labels = NA)
par(lwd = 3, new = TRUE)
pie(1, radius = 0.55, labels = NA)
par(lwd = 0.5, new = TRUE)
pie(1, radius = 0.55, border = NA, labels = NA)
par(lwd = 3)
pie(rep(1,6), radius = 1, col = rainbow_hcl(6, c = 50, l = 70), 
    labels = 360 * 0:5/6)
par(lwd=0.5, new=TRUE)
pie(rep(1, 90), radius = 1, col = rainbow_hcl(90, c = 50, l = 70), border = NA, labels = NA)
par(lwd = 3, new = TRUE)
pie(1, radius = 0.55, labels = NA)
par(lwd = 0.5, new = TRUE)
pie(1, radius = 0.55, border = NA, labels = NA)
@
\caption{\label{fig:wheel} HSV-based and HCL-based color wheel.}
\end{center}
\end{figure}

To overcome these drawbacks, various color spaces have been suggested
that properly map to the perception dimensions, the most prominent of which are
the CIELUV and CIELAB spaces developed by the \cite{color:CIE:2004}. \cite{color:Ihaka:2003}
argues that CIELUV colors are typically preferred for use with emissive technologies
such as computer screens which makes them an obvious candidate for implementation
in statistical software packages. By taking polar coordinates in the UV plane of
CIELUV, HCL colors are obtained, defined by
a triplet $(H, C, L)$ with $H \in [0, 360]$ and $C, L \in [0, 100]$.
%% HCL space has the shape of a distorted double cone: the admissible combinations of
%% chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
%% The lower panel of Figure~\ref{fig:hsv-hcl} shows
%% vertical sections through this space: each of the resulting hue/chroma planes (given
%% luminance) is now properly balanced towards the same gray (going from black to white
%% with increasing luminance) which becomes obvious when converting the colors to
%% a gray scale as in Figure~\ref{fig:hsv-hcl-gray}. 
Given a certain luminance $L$, all colors resulting from different combinations
of hue $H$ and chroma $C$ have the same level of brightness, i.e.,
are balanced towards the same gray and thus look virtually identical
when converted to a gray scale. However, the admissible combinations of
chroma and luminance coordinates (within the space's boundaries) depend on the hue chosen.
The reason for this is that some hues lead to light and others to dark colors,
e.g., full chroma yellow is brighter (i.e., has higher luminance) than full chroma blue.

The balancing of HCL colors
gives us the opportunity to conveniently choose color palettes which code categorical
and/or numerical information by translating it to paths along the three perceptual axes.
However, some care is required for dealing with the irregular shape of the HCL space
which will be addressed in the following sections.


\section{Color palettes} \label{sec:palettes}

\subsection{Qualitative palettes} \label{sec:qualitative}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-construct>>=
if(generate_png) {
  png(file = "pal-q-construct.png", height = 480, width = 480)
  hcl.wheel(luminance = 70, do.label = FALSE, inner.circle = TRUE)
  rect(0.45, -0.05, 0.55, 0.05, col = hcl2hex(0, 50, 70))
  rect(-cos(pi/3)/2-0.05, sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, sin(pi/3)/2+0.05, col = hcl2hex(120, 50, 70))
  rect(-cos(pi/3)/2-0.05, -sin(pi/3)/2-0.05, -cos(pi/3)/2+0.05, -sin(pi/3)/2+0.05, col = hcl2hex(240, 50, 70))
  dev.off()
}
@
\includegraphics{pal-q-construct}
\vspace*{-2cm}
\caption{\label{fig:pal-q-construct} Constructing qualitative palettes. In the hue/chroma
plane for $L = 70$, the dashed circle correponds to a radius $C = 50$ with chosen angles
$H = 0, 120, 240$.}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-q-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(2, 2), mar = c(0, 0, 3, 2))
pal(rainbow_hcl(4, start = 30, end = 300), main = "dynamic [30, 300]")
pal(rainbow_hcl(4, start = 60, end = 240), main = "harmonic [60, 240]")
pal(rainbow_hcl(4, start = 270, end = 150), main = "cold [270, 150]")
pal(rainbow_hcl(4, start = 90, end = -30), main = "warm [90, -30]")
@
\caption{\label{fig:pal-q-examples} Examples for qualitative palettes. Hue is varied
in different intervals for given $C = 50$ and $L = 70$.}
\end{center}
\end{figure}

Qualitative palettes are sets of colors for depicting different categories,
i.e., for coding a categorical variable. Usually, these should give the same
perceptual weight to each category so that no group is perceived to be larger or more
important than any other one. Typical applications of qualitative palettes in
statistics would be bar plots \citep[see][]{color:Ihaka:2003}, pie charts
or highlighted mosaic displays.

\cite{color:Ihaka:2003} describes a simple strategy for choosing such palettes: chroma
and luminance are kept fixed and only the hue is varied for obtaining different colors
which are consequently all balanced towards the same gray. This effect is illustrated
in Figure~\ref{fig:wheel} which shows a color wheel obtained by varying the hue only in
HSV coordinates $(H, 100, 100)$ and HCL coordinates $(H, 50, 70)$. Clearly, not only the
hue but also the amount of chroma and luminance varies for the HSV wheel.

Figure~\ref{fig:pal-q-construct} depicts how the HCL-based color wheel is constructed.
It shows the hue/chroma plane of HCL space given a luminance of $L = 70$. Not all
combinations of hue and chroma are admissible, however for a chroma of $C = 50$ a full
color wheel can be obtained.
For choosing the hues in a certain palette, various strategies are conceivable.
A simple and intuitive one is to use colors as metaphors for categories (e.g., for political parties),
%% (e.g., for political parties as in Figures~\ref{fig:seats} and \ref{fig:votes}),
another approach would be to use segments from
the color wheel corresponding to nearby or distant colors. The latter is shown
in Figure~\ref{fig:pal-q-examples} which depicts
examples for generating qualitative sets of colors $(H, 50, 70)$.
In the upper left panel colors from the full spectrum are used ($H = 30, 120, 210, 300$)
creating a `dynamic' set of colors. The upper right panel shows a `harmonic'
set with $H = 60, 120, 180, 240$. Warm colors (from the blue/green part of the spectrum: 
$H = 270, 230, 190, 150$) and cold colors (from the yellow/red part of the spectrum:
$H = 90, 50, 10, 330$) are shown in the lower left and right panel, respectively.


\subsection{Sequential palettes} \label{sec:sequential}

Sequential palettes are used for coding numerical information that ranges
in a certain interval where low values are considered to be uninteresting and
high values are interesting. Suppose we need to visualize an intensity or
interestingness $i$ which (without loss of generality) is scaled to the unit
interval. A typical application in statistics are heatmaps (see Figure~\ref{fig:bkde}).

The simplest solution to this task is to employ light/dark contrasts, i.e., rely
on the most basic perceptual axis. The interestingness can be coded
by an increasing amount of gray corresponding to decreasing luminance in HCL space:
  \[ (H, 0, 90 - i \cdot 60), \]
where the hue $H$ used does not matter, chroma is set to 0 (i.e., no color), and 
luminance ranges in $[30, 90]$ avoiding the extreme colors white ($L = 100$) and 
black ($L = 0$). Instead of going linearly from light to dark gray, luminance
could also be increased nonlinearly, e.g., by some function $i' = f(i)$ that
controls whether luminance is increased quickly with intensity or not. We found $f(i) = i^p$ 
to be a convenient transformation where the power $p$ can be varied to achieve
different degrees of non-linearity.

Furthermore, the intensity $i$ could additionally be coded by colorfulness (chroma), e.g.,
  \[ (H, 0 + i' \cdot C_{\max}, L_{\max} - i' \cdot (L_{\max} - L_{\min})). \]
This strategy is depicted in the left panel of Figure~\ref{fig:pal-s-construct} for a blue
hue $H = 260$ and different combinations of maximal chroma ($C_{\max} = 0$, $80$ and $100$,
respecitvely) and minimal luminance ($L_{\min} = 30$, $30$ and $50$, respectively).
The first two combinations are also shown in the first two rows of Figure~\ref{fig:pal-s-examples}.
The right panel of Figure~\ref{fig:pal-s-construct} shows that the exact same strategy
is not possible  for the green hue $H = 120$. While the gray colors without chroma can be chosen in 
the same way, there is a stronger trade-off between using dark colors (with low luminance)
and colorful colors (with high chroma). Hence, the second path from light gray to 
full green ends at a much lighter color with $L_{\min} = 75$. 

\setkeys{Gin}{width=\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-construct>>=
if(generate_png) {
  png(file = "pal-s-construct.png", height = 420, width = 840)
  par(mfrow = c(1, 2))
  hue.slice(260, grid.n = 301)
  lines(c(0, 100), c(90, 50), lty = 2)
  lines(c(0, 80), c(90, 30), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 67.5, 52.5, 72.5, col = hcl2hex(260, 50, 70))
  rect(95, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  rect(37.5, 57.5, 42.5, 62.5, col = hcl2hex(260, 40, 60))
  rect(77.5, 27.5, 82.5, 32.5, col = hcl2hex(260, 80, 30))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  hue.slice(120, grid.n = 301)
  lines(c(0, 100), c(90, 75), lty = 2)
  lines(c(2.5, 2.5), c(90, 30), lty = 2)
  rect(0, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(47.5, 80, 52.5, 85, col = hcl2hex(120, 50, 82.5))
  rect(95, 72.5, 100, 77.5, col = hcl2hex(120, 100, 75))
  rect(0, 57.5, 5, 62.5, col = hcl2hex(260, 0, 60))
  rect(0, 27.5, 5, 32.5, col = hcl2hex(260, 0, 30))
  dev.off()
}
@
\includegraphics{pal-s-construct}
\caption{\label{fig:pal-s-construct} Constructing sequential palettes. The chroma/luminance
plane is shown for two hues $H = 260$ (left) and $H = 120$ (right). Colors are chosen by varying
either only luminance or both luminance and chroma.}
\end{center}
\end{figure}

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-s-examples, fig=TRUE, height=5, width=6>>=
par(mfrow = c(5, 1), mar = c(0.25, 0, 0.25, 0))
pal(sequential_hcl(12, c = 0, power = 2.2))
pal(sequential_hcl(12, power = 2.2))
pal(heat_hcl(12, c = c(80, 30), l = c(30, 90), power = c(1/5, 2)))
pal(rev(heat_hcl(12, h = c(0, -100), l = c(75, 40), c = c(40, 80), power = 1)))
pal(terrain_hcl(12, c = c(65, 0), l = c(45, 90), power = c(1/2, 1.5)))
@
\caption{\label{fig:pal-s-examples} Examples for sequential palettes, varying
only luminance (first panel), chroma and luminance (second panel), and hue,
chroma and luminance (remaining panels).}
\end{center}
\end{figure}

To increase the contrast between the colors in the palette even further, the ideas from
the previous sequential palettes can also be combined with qualitative palettes by
simultaneously varying the hue as well:
  \[ (H_2 - i \cdot (H_1 - H_2), C_{\max} - i' \cdot (C_{\max} - C_{\min}),
      L_{\max} - i'' \cdot (L_{\max} - L_{\min})). \]
One application is an HCL-based version of ``heat colors'' that increase from a light yellow
(e.g., $(90, 30, 90)$) to a full red (e.g., $(0, 100, 50)$). To make the change in hue
visible, the chroma needs to increase rather quickly for low values of $i$ and then only
slowly for higher values of $i$. This can be achieved by choosing an appropriate transformation
$i'$ for chroma and a different transformation $i''$ for the luminance.
Such a strategy is adopted for the palettes shown in the lower three rows in
Figure~\ref{fig:pal-s-examples} using different pairs of hues as well as different
chroma and luminance contrasts.


\subsection{Diverging palettes} \label{sec:diverging}

Diverging palettes are also used for coding numerical information ranging in a certain
interval---however, this interval includes a neutral value. Examples for this include
residuals or correlations (both with the neutral value 0) or binary classification
probabilities (with neutral value 0.5) that could be visualized in mosaic plots
\citep[e.g., as in][Figure~3]{color:Zeileis+Meyer+Hornik:2007},
classification maps \citep[e.g., as in][Figure~2]{color:Tenenhaus+Giron+Viennet:2007}
or model-based shading in maps such as Figure~\ref{fig:nigeria}. Analogously to the previous
section, we suppose that we want to visualize an intensity or interestingness $i$
from the interval $[-1, 1]$ (without loss of generality).

\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-construct>>=
if(generate_png) {
  png(file = "pal-d-construct.png", height = 480, width = 534)
  hue260 <- hue.slice(260, grid.n = 301, plot = FALSE)
  hue360 <- hue.slice(360, grid.n = 301, plot = FALSE)
  mychroma <- as.numeric(colnames(hue260))
  luminance <- as.numeric(rownames(hue260))
  nc <- ncol(hue260)
  nl <- nrow(hue260)
  plot(0.5, 0.5, xlim = c(-100, 100), ylim = c(0, 100), type = "n", axes = FALSE,
       xlab = "", ylab = "", yaxs = "i", xaxs = "i", main = "")
  for(i in 1:(nc-1)) {
    rect(mychroma[i], luminance[-nl], mychroma[i] + 100/(nc-1), luminance[-1], border = hue260[,i+1], col = hue260[,i+1])
  }
  for(i in 1:(nc-1)) {
    rect(-mychroma[i], luminance[-nl], -(mychroma[i] + 100/(nc-1)), luminance[-1], border = hue360[,i+1], col = hue360[,i+1])
  }
  axis(1, labels = FALSE, at = c(-100, 0, 100))
  axis(2, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  axis(3, at = -4:4*25, labels=c(4:0*25, 1:4*25))
  axis(4, at = c(0, 30, 50, 60, 70, 90, 100), labels = c(0, 30, 50, 60, 70, 90, 100))
  mtext(c("hue = 0", "hue = 260"), side = 3, at = c(-50, 50), line = 3, cex = 1.2)
  mtext("chroma", side = 3, at = 0, line = 2)
  mtext("luminance", side = 2, at = 50, line = 2)
  mtext("luminance", side = 4, at = 50, line = 2)
  lines(c(-100, 0, 100), c(50, 90, 50), lty = 2)
  rect(-100, 47.5, -90, 52.5, col = hcl2hex(0, 100, 50))
  rect(-55, 67.5, -45, 72.5, col = hcl2hex(0, 50, 70))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(45, 67.5, 55, 72.5, col = hcl2hex(260, 50, 70))
  rect(90, 47.5, 100, 52.5, col = hcl2hex(260, 100, 50))
  lines(c(-80, 0, 80), c(30, 90, 30), lty = 2)
  rect(-85, 27.5, -75, 32.5, col = hcl2hex(0, 80, 30))
  rect(-45, 57.5, -35, 62.5, col = hcl2hex(0, 40, 60))
  rect(-5, 87.5, 5, 92.5, col = hcl2hex(260, 0, 90))
  rect(35, 57.5, 45, 62.5, col = hcl2hex(260, 40, 60))
  rect(75, 27.5, 85, 32.5, col = hcl2hex(260, 80, 30))
  dev.off()
}
@
\includegraphics{pal-d-construct}
\caption{\label{fig:pal-d-construct} Constructing diverging palettes. The chroma/luminance
plane is shown back to back hues $H = 0$ and $H = 260$. Colors are chosen by simultaneously 
varying luminance and chroma.}
\end{center}
\end{figure}


\setkeys{Gin}{width=.8\textwidth}
\begin{figure}[p]
\begin{center}
<<pal-d-examples, fig=TRUE, height=4, width=6>>=
par(mfrow = c(4, 1), mar = c(0.25, 0, 0.25, 0))
pal(diverge_hcl(7))
pal(diverge_hcl(7, c = 100, l = c(50, 90), power = 1))
pal(diverge_hcl(7, h = c(130, 43), c = 100, l = c(70, 90)))
pal(diverge_hcl(7, h = c(180, 330), c = 59, l = c(75, 95)))
@
\caption{\label{fig:pal-d-examples} Examples for diverging palettes with different
pairs of hues and decreasing luminance contrasts.}
\end{center}
\end{figure}

Given useful sequential palettes, deriving diverging palettes is easy: two different hues are
chosen for adding color to the same amount of `gray' at a given intensity $|i|$.
Figure~\ref{fig:pal-d-construct} shows the chroma/luminance plane back to back for the
hues $H = 0$ and 260 with two different paths---giving slightly different emphasis on
luminance or chroma contrasts---from a full red over a neutral gray to a full blue.
As Figure~\ref{fig:pal-s-construct} illustrates, the pair of hues should be chosen carefully
because the admissible values in the chrome/luminance plane differ across hues.
Clearly, for deriving symmetric palettes, only colors from the intersection of the
admissible chroma/luminance planes can be used. The particular hues $H = 0$ and $260$
used in Figure~\ref{fig:pal-d-construct} were chosen because they correspond to similar
geometric shapes in the chroma/luminance plane, allowing for both large chroma and
luminance contrasts. 
If potential viewers of the resulting graphic might be color-blind,
the pair of hues should be taken from the yellow/blue axis of the color wheel
rather than the green/red axis as contrasts on the latter axis are more difficult to 
distinguish for color-blind people \citep{color:Lumley:2006}.

Figure~\ref{fig:pal-d-examples} shows various examples of conceivable combinations of
hue, chroma and luminance. The first palette uses a broader range on the luminance axis
whereas the others mostly rely on chroma contrasts.


\section{Software} \label{sec:software}

Implementing the different color palettes suggested in the previous section 
is extremely easy if the software environment chosen already provides an implementation
of HCL colors: from the formulas provided above the HCL coordinates for a
palette can be conveniently computed. A bit more work is required if the software
package does not yet provide an HCL implementation. In that case, additional
functionality is needed for translating HCL coordinates to the software package's 
color system which may vary between different packages, but standardized RGB (sRGB)
is often used. The typical way of coordinate conversion is to go first from HCL to
CIELUV by simply transforming the polar $H$ and $C$ coordinates back to the original
$U$ and $V$. Subsequently, CIELUV is converted to CIEXYZ which in turn is converted
to sRGB (with the latter conversion depending on the device used for display).
The details of these conversions are somewhat technical and tedious (and hence
omitted here), however the conversion formulas are still straightfoward to
implement and can, for example, be found in \cite{color:Wiki+CIELUV:2007} or
\cite{color:Poynton:2000}.

The \proglang{R} system for statistical computing \citep{color:R:2007} already comes
with an open-source implementation of HCL (and other color spaces) in the package
\pkg{colorspace} \citep{color:Ihaka:2006}. The coordinate transformations mentioned
above are contained in \proglang{C} code within \pkg{colorspace} that are easy to
port to other statistical software systems. Based on \pkg{colorspace} and
the \proglang{R} graphics system \citep[see][]{color:Murrell:2006},
the package \pkg{vcd} \citep{color:Meyer+Zeileis+Hornik:2007} provides implementations
of all palettes discussed above. Qualitative palettes are provided by
\code{rainbow_hcl()} (named after the HSV-based function \code{rainbow()} in base
\proglang{R}). Sequential palettes based on a single hue are implemented in the function
\code{sequential_hcl()} while \code{heat_hcl()} offers sequential palettes based on
a range of hues. Diverging palettes can be obtained by \code{diverge_hcl()}.
Technical documentation along with a large collection of examples is available via
\verb/help("rainbow_hcl", package = "vcd")/. Furthermore, \proglang{R} code for reproducing
Figures~\ref{fig:pal-q-examples}, \ref{fig:pal-s-examples} and \ref{fig:pal-d-examples}
(and some illustrations) can be accessed via \code{vignette("hcl-colors", package = "vcd")}.


\section{Discussion} \label{sec:discussion}

Many statistical graphics---especially when displayed on a computer screen,
e.g., as in interactive usage, electronic papers or presentation slides---employ
colors to code information about a certain variable. Despite this
omnipresence of color, there is often only little guidance in statistical
software packages on how to choose a palette appropriate for a particular
visualization task---auspicious tools such as \pkg{ColorBrewer.org} notwithstanding.
We try to address this problem by suggesting color schemes for coding
categorical information (qualitative palettes) and numerical information
(sequential and diverging palettes) based on the perceptually-based
HCL color space.

We provide paths through HCL space along perceptual axes of the human visual system
so that colors selected along these paths match human perceptual dimensions.
This gives the users the possibility to conveniently experiment with the HCL-based
palettes by varying several simple and intuitive 
graphical parameters. For qualitative
palettes, these are the coordinates on the chroma and luminance axis, respectively,
controlling whether the colors are light or dark and how colorful they are.
For sequential and diverging palettes, the user can decide whether contrasts
in the chroma or luminance direction (or both) should be employed. In our
experience (as illustrated in Section~\ref{sec:motivation}), chroma contrasts
work sufficiently well if a small set of colors is used. However, when a larger
set of colors is used (e.g., for heatmaps where extreme values should be identifiable)
it is much more important to have a big difference in luminance.
%% Another parameter in these 
%% palettes is the rate at which the intensity $|i|$ is increased from $0$ to $1$:
%% Employing a function $|i|^p$ for this, small
%% powers $p$ can be used if palettes with a lot of color should be 
%% constructed (e.g., to clearly separate regions in a classification map). On
%% the other hand, large powers $p$ will result in palettes with less color
%% (e.g., appropriate to highlight only extreme regions firmly classified in such a map).

Based on these conceputal guidelines and the computational tools readily
provided in the \proglang{R} system for statistical computing (and easily implemented in other
statistical software packages), users can generate palettes varying these
graphical parameters and thus adapting the colors to their particular graphical display.


%% \section*{Acknowledgments}
%% 
%% We are thankful to David Meyer, Ross Ihaka, Brian~D.~Ripley,
%% Thomas Kneib, Michael H\"ohle, and Thomas Lumley for feedback, suggestions and discussions.

%% Referees:
%% Ross Ihaka, Thomas Lumley, Cynthia Brewer, Martin Maechler

\bibliography{color}

\end{document}
