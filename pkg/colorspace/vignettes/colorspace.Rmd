---
title: "_colorspace_: A Toolbox for Manipulating and Assessing Colors and Palettes"
author: "Achim Zeileis, Jason C. Fisher, Kurt Hornik, Ross Ihaka, Claire D. McWhite, Paul Murrell, Reto Stauffer, Claus O. Wilke"
date: 2018-09-20
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
bibliography: color.bib
vignette: >
  %\VignetteIndexEntry{colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{colorspace}
  %\VignetteKeywords{RGB, sRGB, XYZ, LUV, LAB, HLS, HSV, HCL, qualitative palette, sequential palette, diverging palette, shiny, visualization, color vision deficiency}
  %\VignettePackage{colorspace}
---
```{r echo=FALSE, message=FALSE}
library("colorspace")
```

## Color spaces

At the core of the _colorspace_ package there are various utilities for computing with
color spaces (as the name conveys). Thus, the package helps to map various three-dimensional
representations of color to each other, see @color:Ihaka:2003. A particularly important
mapping was the one from the perceptually-based and device-independent color model
HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color
specifications in many systems based on the corresponding hex codes (e.g., in HTML but also
in R). For completeness further standard color models were included as well in the package.
The connections are illustrated in the following graph:


```{r fig.width = 9.5, fig.height = 4.5, fig.align = "center", echo = FALSE, dev = "svg"}
par(mar = rep(0, 4))

d <- data.frame(
  x = c(1, 1, 2, 2, 3, 4, 5, 5, 5, 6),
  y = c(1, 3, 1, 3, 2, 2, 1, 3, 2, 2),
  lab = c("polarLAB", "polarLUV\n(= HCL)", "LAB", "LUV", "XYZ", "RGB", "HLS", "HSV", "sRGB", "hex"),
  stringsAsFactors = FALSE
)

plot(0, 0, type = "n", axes = FALSE, xlab = "", ylab = "",
  xlim = c(0.7, 6.3), ylim = c(0.4, 3.6))
lines(y ~ x, data = d[-c(1, 3, 7, 8),])
lines(y ~ x, data = d[c(1, 3, 5),])
lines(y ~ x, data = d[c(6, 7, 9),])
lines(y ~ x, data = d[c(6, 8, 9),])
points(y ~ x, data = d[c(1, 2, 7, 8), ], pch = 21, bg = "lightgray", cex = 12)
points(y ~ x, data = d[c(3, 4, 5, 6, 9), ], pch = 22, bg = "lightgray", cex = 12)
points(y ~ x, data = d[10, ], pch = 23, bg = "white", cex = 12)

text(d$x, d$y, d$lab)
text(3.5, 2, "white point\n= D65", cex = 0.7, pos = 3)
text(4.56, 2, "gamma\n(= 2.4)", cex = 0.7, pos = 3)
```

Color models that are (or try to be) perceptually-based are displayed with circles,
other color models with rectangles. The corresponding classes and eponymous class
constructors in _colorspace_ are:

* `RGB` for the classic Red-Green-Blue color model that mixes three primary colors
  with different intensities to obtain a spectrum of colors. The advantage of this
  color model is (or was) that it corresponded to how computer and TV screens generated
  colors, hence it was widely adopted and still is the basis for color specifications
  in many systems. For example, the hex color codes are employed in HTML but also in R.
  However, the RGB model also has some important drawbacks: It does not take into
  account the output device properties, it is not perceptually uniform (a unit step
  within RGB does not produce a constant perceptual change in color), and it is
  unintuitive for humans to specify colors (say brown or pink) in this space.
* `sRGB` addresses the issue of device dependency by adopting a so-called gamma
  correction. Therefore, the gamma-corrected standard RGB (sRGB), as opposed to the
  linearized RGB above, is a good model for specifying colors in software and for
  hardware. But it is still unintuitive for humans to work directly with this.
  Therefore, sRGB is a good place to end up in a color space manipulation but
  it is not a good place to start.
* `HSV` is a simple transformation of the (s)RGB space that tries to capture the
  perceptual axes: _hue_ (dominant wavelength, the type of color), _saturation_
  (colorfulness), and _value_ (brightness, i.e., light vs. dark). Unfortunately,
  the three axes in the HSV model are confounded so that, e.g., brightness changes
  dramaticaly with hue.
* `HLS` (Hue-Lightness-Saturation) is another transformation of (s)RGB that tries
  to capture the perceptual axes. It does a somewhat better job but the dimensions
  are still strongly confounded.
* `XYZ` was established by the CIE (Commission Internationale de l'Eclairage)
  based on experiments with human subjects. It provides a unique triplet of
  XYZ values, coding the standard observer's perception of the color. It is
  device-independent but it is not perceptually uniform and the XYZ coordinates
  have no intuitive meaning.
* `LUV` and `LAB` were therefore proposed by the CIE as perceptually uniform
  color spaces where the former is typically preferred for emissive technologies
  (such as screens and monitors) whereas the latter is usually preferred when
  working with dyes and pigments. However, the three axes of these two spaces
  still do not correspond to human perceptual axes.
* `polarLUV` and `polarLAB` therefore take polar coordinates in the UV plane
  and AB plane, respectively. Specifically, the polar coordinates of the LUV
  model are known as the HCL (Hue-Chroma-Luminance) model. These capture the
  human perceptual axes very well without confounding effects as in the HSV or
  HLS approaches. (More details follow below.)

All the S4 classes listed above inherit from a virtual class `color` which are
internally always represented by matrices with three columns (corresponding to
the different three dimensions).

Utilities:

* `as()`
* `coords()`
* `hex()`
* `hex2RGB()`
* `readRGB()`
* `readhex()`
* `writehex()`
* `whitepoint()`


## HCL-based palettes

As motivated in the previous section, the HCL space is particularly useful for
specifying individual colors and color palettes as its three axes match those
of the human visual system very well. Therefore, the _colorspace_ package provides
three types of palettes based on the HCL model:

* _Qualitative:_ Designed for coding categorical information, i.e.,
  where no particular ordering of categories is available and every color
  should receive the same perceptual weight.
* _Sequential:_ Designed for coding ordered/numeric information, i.e.,
  where colors go from high to low (or vice versa).
* _Diverging:_ Designed for coding numeric information around a central
  neutral value, i.e., where colors diverge from neutral to two extremes.

The corresponding functions are `qualitative_hcl()`, `sequential_hcl()`,
and `diverging_hcl()`. Their construction principles are explained in more detail below.

To facilitate obtaining good sets of colors, HCL parameter combinations that yield
useful palettes are accessible by name. These can be listed using the function
`hcl_palettes()`:

```{r}
hcl_palettes()
```

To inspect the HCL parameter combinations for a specific palette simply include the `name`
where upper- vs. lower-case, spaces, etc. are ignored for matching the label, i.e.,
`"dark2"` matches `"Dark 2"`:

```{r}
hcl_palettes(name = "dark2")
```

To compute the actual color hex codes (representing sRGB coordinates), the functions
`qualitative_hcl()`, `sequential_hcl()`, and `diverging_hcl()`, respectively, can be used.
Either all parameters can be specified "by hand" through the HCL parameters, an entire
palette can be specified "by name", or the name-based specification can be modified by a
few HCL parameters. In case of the HCL parameters, either a vector-based specification
such as `h = c(0, 270)` or individual parameters `h1 = 0` and `h2 = 270`
can be used.

```{r}
qualitative_hcl(4, h = c(0, 270), c = 50, l = 60)
qualitative_hcl(4, h1 = 0, h2 = 270, c1 = 50, l1 = 60)
qualitative_hcl(4, palette = "dark2")
qualitative_hcl(4, palette = "dark2", c = 80)
```

#### Qualitative palettes

`qualitative_hcl()` distinguishes the underlying categories by a sequence of
hues while keeping both chroma and luminance constant to give each color in the
resulting palette the same perceptual weight. Thus, `h` should be a pair of
hues (or equivalently `h1` and `h2` can be used) with the starting and
ending hue of the palette. Then, an equidistant sequence between these hues is
employed, by default spanning the full color wheel (i.e, the full 360 degrees).
Chroma `c` (or equivalently `c1`) and luminance `l` (or equivalently
`l1`) are constants.

In the following graphic the available named palettes are shown. The first five
palettes are close to the _ColorBrewer.org_ palettes of the same name [@color:Harrower+Brewer:2003].
They employ different levels of chroma and luminance and, by default, span the full
hue range. The remaining four palettes are taken from @color:Ihaka:2003. They are
based on the same chroma (= 50) and luminance (= 70) but the hue is restricted to
different intervals.

```{r fig.width = 5.5, fig.height = 5.0, fig.align = "center", dev = "png", dpi = 48, out.width = "60%"}
hcl_palettes("qualitative", plot = TRUE)
```

When qualtitative palettes are employed for shading areas in statistical displays
(e.g., in bar plots, pie charts, or regions in maps), then it is typically
less distracting to use lighter colors (with moderate chroma and high luminance)
such as "Pastel 1" or "Set 3". When coloring points or lines then more flashy
colors (with high chroma) are often required: On a white background a moderate
luminance as in "Dark 2" or "Dark 3" usually works better while on a black/dark
background the luminance should be higher as in "Set 2" for example.


#### Sequential palettes (single-hue)

`sequential_hcl()` codes the underlying numeric values by a monotonic sequence
of increasing (or decreasing) luminance. Thus, the `l` argument should provide
a vector of length 2 with starting and ending luminance (equivalently, `l1` and
`l2` can be used). Without chroma (i.e., `c = 0`), this simply corresponds
to a grayscale palette like `gray.colors()`, see "Grays" and "Light Grays" below.

For adding chroma, a simple strategy would be to pick a single hue (via `h` or `h1`)
and then decrease chroma from some value (`c` or `c1`) to zero (i.e., gray) along with
increasing luminance. For bringing out the extremes (a dark high-chroma color vs.
a light gray) this is already very effective, see "Blues 2", "Purples 2", "Reds 2",
and "Greens 2".

For distinguishing also colors in the middle two strategies can be employed:
(a) Hue can be varied as well by specifying an interval of hues in `h` (or beginning
hue `h1` and ending hue `h2`). More details are provided in the next section.
(b) Instead of a decreasing chroma a triangular chroma trajectory can be employed
from `c1` over `cmax` to `c2` (or equivalently a vector `c` of
length 3). This yields high-chroma colors in the middle of the palette that are
more easily distinguished from the dark and light extremes. See "Blues 3", "Purples 3",
"Reds 3", and "Greens 3" below.

Instead of employing linear trajectories in the chroma or luminance coordinates
some palettes employ a power transformation of the chroma and/or luminance
trajectory. Either a vector `power` of length 2 or separate `p1` (for chroma)
and `p2` (for luminance) can be specified. If missing, the latter defaults to the
former.

```{r fig.width = 6.5, fig.height = 6.0, fig.align = "center", dev = "png", dpi = 48, out.width = "70%"}
hcl_palettes("sequential (single-hue)", n = 7, plot = TRUE)
```

All except the last palette are inspired by the _ColorBrewer.org_ palettes with
the same base name [@color:Harrower+Brewer:2003] but restricted to a single hue only.
They are intended for a white/light background. The last palette is taken from
the scientific color maps of @color:Crameri:2018 and is intended for a black/dark
background and hence the order is reversed starting from a light blue (not a light gray).

To distinguish many colors in a sequential palette it is important to have a strong
contrast on the luminance axis, possibly enhanced by an accompanying pronounced
variation in chroma. When only a few colors are needed (e.g., for coding an ordinal
categorical variable with few levels) then a lower luminance contrast may suffice.



#### Sequential palettes (multi-hue)

To not only bring out extreme colors in a sequential palette but also better distinguish
middle colors it is a common strategy to employ a sequence of hues. Thus, the basis
of such a palette is still a monotonic luminance sequence as above (combined with a
monotonic or triangular chroma sequence). But, instead of a single hue, an interval
of hues in `h` (or beginning hue `h1` and ending hue `h2`) is specified.

`sequential_hcl()` allows to combine variations in hue (`h` and `h1`/`h2`, respectively),
chroma (`c` and `c1`/`c2`/`cmax`, respectively),
luminance (`l` and `l1`/`l2`, respectively), and
power transformations for the chroma and luminance trajectories
(`power` and `p1`/`p2`, respectively). This yields a broad variety of sequential
palettes, including many that closely match other well-known color palettes.
The plot below shows all the named multi-hue sequential palettes in _colorspace_:

* "Purple-Blue" to "Terrain 2" are various palettes created during the development
  of _colorspace_, e.g., by @color:Zeileis+Hornik+Murrell:2009 or @color:Stauffer+Mayr+Dabernig:2015
  among others.
* "Viridis" to "Inferno" closely match the palettes that @color:Smith+VanDerWalt:2015
  developed for _matplotlib_ and that gained popularity recently.
* "Dark Mint" to "BrwnYl" closely match palettes provided in _CARTO_ [@color:CARTO:2018].
* "YlOrRd" to "Blues" closely match _ColorBrewer.org_ palettes [@color:Harrower+Brewer:2003].
* "Lajolla" and "Turku" closely match the scientific color maps of the same name by
  @color:Crameri:2018 and are intended for a black/dark background.

```{r fig.width = 8.5, fig.height = 9.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
hcl_palettes("sequential (multi-hue)", n = 7, plot = TRUE)
```

Note that the palettes differ substantially in the amount of chroma and luminance
contrasts, respectively. For example, many palettes go from a dark high-chroma color
to a neutral low-chroma color (e.g., "Reds", "Purples", "Greens", "Blues") or even
light gray (e.g., "Purple-Blue"). But some palettes also employ relatively high chroma
throughout the palette (e.g., the viridis and many _CARTO_ palettes). To emphasize
the extremes the former strategy is typically more suitable while the latter works
better if all values along the sequence should receive some more perceptual weight.



#### Diverging palettes

`diverging_hcl()` codes the underlying numeric values by a triangular luminance
sequence with different hues in the left and in the right "arm" of the palette. Thus,
it can be seen as a combination of two sequential palettes with some restrictions:
(a) a single hue is used for each arm of the palette, (b) chroma and luminance trajectory
are balanced between the two arms, (c) the neutral central value has zero chroma.
To specify such a palette a vector of two hues `h` (or equivalently `h1`
and `h2`), either a single chroma value `c` (or `c1`) or a vector
of two chroma values `c` (or `c1` and `cmax`), a vector of two
luminances `l` (or `l1` and `l2`), and power parameter(s) `power`
(or `p1` and `p2`) are used. For more flexible diverging palettes without
the restrictrictions above (and consequently more parameters) see the next
section.

The plot below shows all such diverging palettes that have been named in _colorspace_:

* "Blue-Red" to "Cyan-Magenta" have been developed for _colorspace_ starting from
  @color:Zeileis+Hornik+Murrell:2009, taking inspiration from various other palettes,
  including more balanced and simplified versions of several _ColorBrewer.org_
  palettes [@color:Harrower+Brewer:2003].
* "Tropic" closely matches the palette of the same name from _CARTO_ [@color:CARTO:2018].
* "Broc" to "Vik" and "Berlin" to "Tofino" closely match the scientific color maps of the same name by
  @color:Crameri:2018, where the first three are intended for a white/light background and
  the other three for a black/dark background.

```{r fig.width = 6.5, fig.height = 7.5, fig.align = "center", dev = "png", dpi = 48, out.width = "70%"}
hcl_palettes("diverging", n = 7, plot = TRUE)
```

When choosing a particular palette for a display similar considerations apply as
for the sequential palettes. Thus, large luminance differences are important when
many colors are used while smaller luminance contrasts may suffice for palettes with
fewer colors etc.


#### Flexible diverging palettes

The `divergingx_hcl()` provides more flexible diverging palettes by
simply calling `sequential_hcl()` twice with prespecified sets of hue, chroma,
and luminance parameters. Thus, it does not pose any restrictions that
the two "arms" of the palette need to be balanced and also allows to go
through a non-gray neutral color (typically light yellow).
Consequently, the chroma/luminance paths can be rather unbalanced

The plot below shows all such flexible diverging palettes that have been named in _colorspace_:

* "ArmyRose" to "Tropic" closely match the palettes of the same name from _CARTO_ [@color:CARTO:2018].
* "PuOr" to "Spectral" closely match the palettes of the same name from _ColorBrewer.org_ [@color:Harrower+Brewer:2003].

```{r fig.width = 6.5, fig.height = 8.0, fig.align = "center", dev = "png", dpi = 48, out.width = "70%"}
divergingx_palettes(n = 7, plot = TRUE)
```

Typically, the more restricted diverging palettes should be preferred because they are
more balanced. However, by being able to go through light yellow as the neutral
color warmer diverging palettes are available.


#### HCL (and HSV) color palettes corresponding to base R palettes

`rainbow_hcl()`
`heat_hcl()`
`terrain_hcl()`
`diverging_hsv()`


## Palette visualization and assessment


#### Color swatches: `swatchplot()`

swatches of several palette vectors

```{r fig.width = 4, fig.height = 2.2, fig.align = "center", dev = "png"}
swatchplot(
  "Hue"       = sequential_hcl(5, h = c(0, 300), c = c(60, 60), l = 65),
  "Chroma"    = sequential_hcl(5, h = 0, c = c(100, 0), l = 65, rev = TRUE, power = 1),
  "Luminance" = sequential_hcl(5, h = 260, c = c(25, 25), l = c(25, 90), rev = TRUE, power = 1),
  off = 0
)
```

swatches of named palette matrices

```{r fig.width = 11.5, fig.height = 3.5, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
bprg <- c("Blues", "Purples", "Reds", "Greens")
swatchplot(
  "Single-hue"            = t(sapply(paste(bprg, 2), sequential_hcl, n = 7)),
  "Single-hue (advanced)" = t(sapply(paste(bprg, 3), sequential_hcl, n = 7)),
  "Multi-hue (advanced)"  = t(sapply(bprg,           sequential_hcl, n = 7)),
  nrow = 5
)
```

#### HCL (and RGB) spectrum: `specplot()`

spectrum of HCL-based palettes: qualitative/sequential/diverging

```{r fig.width = 5, fig.height = 5, fig.align = "center", dev = "png"}
specplot(qualitative_hcl(100, "Set 2"))
```

```{r fig.width = 5, fig.height = 5, fig.align = "center", dev = "png"}
specplot(sequential_hcl(100, "Blues 2"))
```

```{r fig.width = 5, fig.height = 5, fig.align = "center", dev = "png"}
specplot(diverging_hcl(100, "Blue-Red"))
```

spectrum of the (in)famous RGB rainbow palette (in both RGB and HCL)

```{r fig.width = 5, fig.height = 7.5, fig.align = "center", dev = "png"}
specplot(rainbow(100), rgb = TRUE)
```


#### Trajectories in HCL space: `hclplot()`

For qualitative palettes luminance and chroma are fixed, varying only hue

```{r fig.width = 4, fig.height = 4, fig.align = "center", dev = "png"}
hclplot(qualitative_hcl(9, c = 50, l = 70))
```

Single-hue sequential palette (h = 260) with linear trajectory and
advanced single-hue sequential palette with triangular chroma trajectory
(piecewise linear vs. power-transformed).

```{r fig.width = 11.5, fig.height = 4.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(1, 3))
hclplot(sequential_hcl(7, h = 260, c = 80, l = c(35, 95), power = 1))
hclplot(sequential_hcl(7, h = 245, c = c(40, 75, 0), l = c(30, 95), power = 1))
hclplot(sequential_hcl(7, h = 245, c = c(40, 75, 0), l = c(30, 95), power = c(0.8, 1.4)))
```

Multi-hue sequential palette with small hue range and triangular chroma vs.
large hue range and linear chroma trajectory.

Balanced diverging palette constructed from two simple single-hue sequential
palettes (for hues 260/blue and 0/red)

```{r fig.width = 11.5, fig.height = 4.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(1, 3))
hclplot(sequential_hcl(7, h = c(260, 220), c = c(50, 75, 0), l = c(30, 95), power = 1))
hclplot(sequential_hcl(7, h = c(260, 60), c = 60, l = c(40, 95), power = 1))
hclplot(diverge_hcl(7, h = c(260, 0), c = 80, l = c(35, 95), power = 1))
```


#### Demonstration of statistical graphics:  `demoplot()`

All built-in demos with the same `sequential_hcl(5, "Heat")` palette

```{r echo = FALSE, fig.width = 8.5, fig.height = 8.5, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(3, 3))
cl <- sequential_hcl(5, "Heat")
for (i in c("map", "heatmap", "scatter", "spine", "bar", "pie", "perspective", "mosaic", "lines")) {
  demoplot(cl, type = i)
  mtext(side = 3, text = i, line = 1.5)
}
```

Qualitative palettes: light pastel colors for shading areas (pie)
and darker colorful palettes for points or lines

```{r fig.width = 8.5, fig.height = 3.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(1, 3))
demoplot(qualitative_hcl(4, "Pastel 1"), type = "pie")
demoplot(qualitative_hcl(4, "Set 2"), type = "scatter")
demoplot(qualitative_hcl(4, "Dark 3"), type = "lines")
```

Sequential palettes: display almost continuous gradients with
strong luminance contrasts (heatmap, perspective) and colorful
sequential palette for spine plot with only a few ordered categories

```{r fig.width = 8.5, fig.height = 3.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(1, 3))
demoplot(sequential_hcl(99, "Purple-Blue"), type = "heatmap")
demoplot(sequential_hcl(99, "Reds"), type = "perspective")
demoplot(sequential_hcl(4, "Viridis"), type = "spine")
```

Diverging palettes: display almost continuous gradient with
strong luminance contrast bringing out the extremes (map),
more colorful palette with lower luminance contrasts for displays
with fewer colors (mosaic, bar)

```{r fig.width = 8.5, fig.height = 3.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(1, 3))
demoplot(diverging_hcl(99, "Tropic", power = 2.5), type = "map")
demoplot(diverging_hcl(5, "Green-Orange"), type = "mosaic")
demoplot(diverging_hcl(5, "Blue-Red 2"), type = "bar")
```

Some palettes that work well on black backgrounds

```{r fig.width = 8.5, fig.height = 6.0, fig.align = "center", dev = "png", dpi = 48, out.width = "100%"}
par(mfrow = c(2, 3), bg = "black")
demoplot(sequential_hcl(9, "Oslo"), "heatmap")
demoplot(sequential_hcl(9, "Turku"), "heatmap")
demoplot(sequential_hcl(9, "Inferno", rev = TRUE), "heatmap")
demoplot(qualitative_hcl(9, "Set 2"), "lines")
demoplot(diverging_hcl(9, "Berlin"), "scatter")
demoplot(diverging_hcl(9, "Cyan-Magenta", l2 = 20), "lines")
```



## Color vision deficiency emulation

`simulate_cvd()`

* `deutan()`
* `protan()`
* `tritan()`

`deutanomaly_cvd`
`protanomaly_cvd`
`tritanomaly_cvd`


## Color manipulation and utilities

* `desaturate()`
* `darken()`
* `lighten()`
* `max_chroma()`
* `mixcolor()`


## Color apps (shiny and Tcl/Tk)

`choose_palette()`
`hclwizard()`
`hcl_wizard()`

`choose_color()`
`hcl_color_picker()`

`cvd_emulator()`
`interpolate_cvd_transform()`


## HCL-based color scales for ggplot2

All scales are called via the scheme `scale_<aesthetic>_<datatype>_<colorscale>()`,
where `<aesthetic>` is the name of the aesthetic (`fill`, `color`, `colour`),
`<datatype>` is the type of the variable plotted (`discrete` or `continuous`) and
`<colorscale>` sets the type of the color scale used
(`qualitative`, `sequential`, `diverging`, `divergingx`).

Thus, the discrete scales for fill aesthetics are:

* `scale_fill_discrete_qualitative()`
* `scale_fill_discrete_sequential()`
* `scale_fill_discrete_diverging()`
* `scale_fill_discrete_divergingx()`

And the corresponding continuous scales are:

* `scale_fill_continuous_qualitative()`
* `scale_fill_continuous_sequential()`
* `scale_fill_continuous_diverging()`
* `scale_fill_continuous_divergingx()`

Analogous functions for color aesthetics just replace `fill` with `color` (or equivalently `colour`).


## References
